<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Parsers y Abstract Syntax Tree</title>
    <link rel="stylesheet" href="../assets/index.css">
</head>
<body>
    <h1>Parsers y Abstract Syntax Tree</h1>

    <p>
        El JS Engine recibe el código fuente y lo procesa de la siguiente manera:

        El parser descompone y crea tokens que integran el AST.
        Se compila a bytecode y se ejecuta.
        Lo que se pueda se optimiza a machine code y se reemplaza el código base.
        Un SyntaxError es lanzado cuando el motor JavaScript encuentra partes que
        no forman parte de la sintaxis del lenguaje y esto lo logra gracias a que se
        tiene un AST generado por el parser.
    </p>
    <br>
    <p>
        El parser es del 15% al 20% del proceso de ejecución por lo que hay que usar
        parser del código justo en el momento que lo necesitamos y no antes de saber
        si se va a usar o no.
    </p>

    <h2>¿Qué hace un JS Engine?</h2>
    <ul>
        <li>Recibe el código fuente</li>
        <li>Parsera el código y produce un Abstract Syntax Tree (AST)</li>
        <li>Se compila a bytecode y se ejecuta</li>
        <li>Se optimiza a machine code y se reemplaza el código base</li>
    </ul>
    <img src="../assets/img/proceso_de_javascript.png" alt="proceso de javascript">

    <h2>¿Qué hace un parser?</h2>
    <img src="../assets/img/parser.png" alt="proceso parcer">
    <ul>
        <li>Agarra el cófigo fuente y lo lee</li>
        <li>Lo descompone en tokens: (Los tokens se refierena que el parser identifica que "let" es una palabra clave, que el simbolo de "+" es un operador)</li>
        <li>Entre el medio cuando el parser esta analizando el codigo y hay algo que no hace sentido arroja un SyntaxError
            <ul>
                <li>Un SyntaxError es lanzado cuando el moto de JavaScript se encuentra
                    con partes de código que no forman parte de la sintaxis del lenhuaje al momento
                    de analizar el código.
                    <a href="https://developer.mozilla.org/es/docs/Web/JavaScript/Referencia/Objetos_globales/SyntaxError">Referencia MDN</a>
                </li>
            </ul>
        </li>

        <li>Un vez optenidos todos los token hace el (AST)</li>
    </ul>
    <ul>
        <li>Google Dice:</li>
        <li>Que el Parsing es de un 15- 20 % del proceso de ejecución </li>
        <li>La mayoria del JavaScript en una página nunca se ejecuta</li>
        <li>Esto hace que el bundling y code splitting sea muy importante! (significa que el código debe ser empaquetado de forma eficiente.)</li>
    </ul>

    <ul>
        <li>Referencia de AST</li>
        <li><a href="https://astexplorer.net/">ASTexplorer</a> </li>
    </ul>

    <ul>
        <li>Referencia de Tokenización</li>
        <li><a href="https://esprima.org/">Esprima</a></li>
    </ul>
    <ul>
        <li>Existen dos modos de hacer Parser</li>
        <li>V8 motor de Google Ghrome</li>
        <li>Eager Parsing:
            <ul>
                <li>Encuentra errors</li>
                <li>Crea el AST</li>
                <li>Construye scopes (sabemos que variables se pueden leer en que parte del código)</li>
            </ul>
        </li>
        <li> Lazy Parsing:
            <ul>
                <li>Retrasamos una parte del código para analizarla luego</li>
                <li>Doble de rápido que el eager parser</li>
                <li>NO crea el AST</li>
                <li>Construye los scopes parcialmente ( se tiene un poco de información</li>
            </ul>
        </li>
    </ul>
    <h2>Abstract Syntax Tree (AST)</h2>
    <p>Es un grafo (estructura de datos) que representa un programa</p>

    <ul>
        <li>Se usa en:
            <ul>
                <li>JavaScript Engine</li>
                <li>Bundlers: Webpack, Rollup, Parcel</li>
                <li>Transpilers: Babel</li>
                <li>Linters: ESLint, Prettify</li>
                <li>Type Checkers: TypeScript, Flow</li>
                <li>Syntax Highlighters</li>
            </ul>
        </li>
    </ul>

    <p>
        Una vez tenemos el AST ahora hay que convertirlo a Bytecode.
        <br>
        <br>
        <em>Bytecode</em> es como el código assembler pero en lugar de operar
        en el procesador opera en la máquina virtual V8 del navegador.
        <br>
        <br>
        <em>Machine code</em> es el más bajo nivel, es código binario que
        va directo al procesador.
        <br>
        <br>
        <em>El profiler</em> se sitúa en medio del bytecode y el optimizador
        <br>
        <br>
        <p>
            Cada máquina virtual tiene sus particularidades,
            por ejemplo V8 tiene algo llamado Hot Functions.
        </p>
        <br>
        <p>Cuando una sentencia función es ejecutada muy frecuentemente,
            V8 la denomina como una hot function y hace una optimización
            que consiste en convertirla a machine code para no tener que
            interpretarla de nuevo y agilizar su ejecución.
        </p>
        <br>
        <p> Cada navegador tiene su implementación de JavaScript Engine:</p>
        <ul>
            <li>
                SpiderMonkey - Firefox
            </li>
            <li>
                JavaScriptCore - Safari
            </li>
            <li>
                Chackra - Edge
            </li>
            <li>
                V8 - Chrome
            </li>
        </ul>
    </p>

    <h2>Bytecode vs Machine Code</h2>
    <ul>
        <li>Bytecode:</li>
        <ul>
            <li>Código parecido a assembly</li>
            <li>Portatil</li>
            <li>Ejecutado por una virtual machine</li>
        </ul>
    </ul>
    <ul>
        <li>Machine Code:</li>
        <ul>
            <li>Binario</li>
            <li>Instrucciones específicas a una arquitectura o procesador</li>
        </ul>
    </ul>
</body>
</html>